# Компилятор

Компиляция программ на своём эзотерическом языке для [собственного `SPU`](https://github.com/ralex2304/Processor) и `x86-64`.

## Содержание

// TODO содержание

## Процесс компиляции

![Compilation process](img/compilation_sequence.svg)

- [Frontend](#frontend) - лексический разбор текста программы и создание абстрактного синтаксического дерева (AST);
- [Middleend](#middleend) - оптимизации и преобразования AST:
    - свёртка констант;
    - удаление мёртвого кода;
    - дифференцирование математических выражений;
- [Backend](#backend) - генерация линейного архитектурно-независимого промежуточного представления (IR);
- [IR Backend](#ir-backend) - обработка IR:
    - оптимизации:
        - удаление избыточных парных перемещений данных;
        - свёртка операций со стеком;
    - создание бинарного исполняемого файла программы, генерация ассемблерного листинга.

> [!NOTE]
> Компилятор состоит из 4 отдельных программ, описание которых находится ниже. Их названия обусловлены [историей развития проекта](#развитие-проекта). Традиционно структура компилятора несколько другая. Например, в LLVM синтаксическое дерево не выходит за пределы frontend, а части компилятора обмениваются IR. В данном проекте основной структурой является AST, поэтому IR появляется лишь лишь на backend.

### Frontend

#### Лексер

Сначала текст программы разбирается на лексемы. Такой подход позволил облегчить дальнейшую обработку конструкций языка, ввести синонимичные ключевые слова, а также игнорировать комментарии.

<img rel="Ключевые слова" src="img/terminals.png" width="75%">

> [!NOTE]
> [Полный список ключевых слов](frontend/src/terminals.h). **Осторожно, встречается ненормативная лексика.**

#### Парсер

Массив лексем преобразуется в абстрактное синтаксическое дерево (AST) при помощи алгоритма рекурсивного спуска. Так как реализация алгоритма тяжело читаема после написания, для верификации и дальнейшей поддержки был создан файл с формальным описанием синтаксических конструкций и приоритета операций языка.

Условные обозначения:
- `<expr name> := <expr>` - определение нового типа выражения
- `'<keyword>'` - ключевое слово
- `{<expr>}` - скобки для обозначения приоритета
- `!<expr>` - выражение не должно встретиться
- `<expr>?` - необязательное выражение
- `<expr>*` - выражение может не встретиться или встретиться несколько раз
- `<expr1> | <expr2>` - выражение 1 или выражение 2

```
// 'CH_' - means that function exits without error (gives choice)

Main := {'CMD_SEPARATOR'? {CH_DefFunc | CH_DefVar} 'CMD_SEPARATOR'?}* 'TERMINATOR'

CH_DefFunc := VarName {'VAR' | 'CONST'} 'OPEN_BRACE' FuncArgsDef 'CLOSE_BRACE' 'CMD_SEPARATOR'? CH_Commands

CH_DefVar := VarName {'OPEN_INDEX_BRACE' Expr 'CLOSE_INDEX_BRACE'}? 'VAR' 'CONST'? {'ASSIGNMENT' Expr {'VAR_SEPARATOR' Expr}* }?

CH_Commands := 'OPEN_SCOPE' 'CMD_SEPARATOR'? {Command {'CMD_SEPARATOR' Command}*} 'CMD_SEPARATOR'? 'CLOSE_SCOPE'

Command := {CH_Commands | CH_DefVar | CH_CommandWithArg | CH_ComplexCommand | CH_CommandWithConstArg | SimpleCommand}

// ---------------------------------------------MATHS------------------------------------------------

Expr := {VarName {'OPEN_INDEX_BRACE' Expr 'CLOSE_INDEX_BRACE'}? {{'ASSIGNMENT' !'ASSIGNMENT'} | {{'MATH_ADD' | 'MATH_SUB' | 'MATH_MUL' | 'MATH_DIV'} 'ASSIGNMENT'}} Expr} | MathLvl1

MathLvl1 := MathLvl2 {{{{'ASSIGNMENT' | 'LOGIC_NOT' | 'LOGIC_LOWER' | 'LOGIC_GREATER'} 'ASSIGNMENT'} | {'LOGIC_LOWER' | 'LOGIC_GREATER'}} MathLvl2}*

MathLvl2 := MathLvl3 {{'MATH_ADD' | 'MATH_SUB'} MathLvl3}*

MathLvl3 := MathLvl4 {{'MATH_MUL' | 'MATH_DIV'} MathLvl4}*

MathLvl4 := MathLvl5 {'MATH_POW' MathLvl5}*

MathLvl5 := {{'MATH_SUB' MathLvl5} | {{'OPEN_BRACE' Expr 'CLOSE_BRACE'} | CH_Binary | CH_Unary | Primary}}

```

[Актуальная версия синтаксиса](Programs/syntax_examples/syntax.txt).

#### Стандарт AST

Для удобства разработки и поддержки был создан стандарт синтаксического дерева. Полное описание находится в отдельном [репозитории](https://github.com/ralex2304/LangStandard/#стандарт-ast---abstract-syntax-tree).

Далее представлена таблица типов узлов дерева:

|Num| Name             |Type    | Description |
|:-:|:-----------------|:------:|:------------|
| 1 | CMD_SEPARATOR    | LIST   | Разделитель команд. Имитирует список. Левый потомок - команда, правого или нет, или такой же разделитель
| 2 | VAR_DEFINITION   | BINARY | Определение переменной. Слева лист типа переменная, справа либо ничего, либо выражение
| 3 | CONST_VAR_DEF    | UNARY  | Опциональный родитель VAR_DEFINITION и ARRAY_DEFINITION
| 4 | ARRAY_DEFINITION | BINARY | Определение массива. Слева поддерево: (VAR_SEPARATOR (переменная) (константное выражение - индекс)). Справа либо ничего, либо список выражений через VAR_SEPARATOR
| 5 | FUNC_DEFINITION  | BINARY | Определение функции. Слева поддерево: (VAR_SEPARATOR (переменная) (поддерево аргументов (список из VAR_SEPARATOR))). Справа список команд через CMD_SEPARATOR
| 6 | ASSIGNMENT       | BINARY | Присваивание. Слева лист переменная, справа выражение
| 7 | ASSIGNMENT_ADD   | BINARY |
| 8 | ASSIGNMENT_SUB   | BINARY |
| 9 | ASSIGNMENT_MUL   | BINARY |
|10 | ASSIGNMENT_DIV   | BINARY |
|11 | ARRAY_ELEM       | BINARY | Элемент массива. Слева лист переменная - имя массива, справа выражение - индекс элемента
|15 | VAR_SEPARATOR    | LIST   | Имитатор списка для аргументов функции и т.п.
|16 | FUNC_CALL        | BINARY | Вызов функции. Слева лист переменная, справа список выражений через VAR_SEPARATOR
|17 | RETURN           | UNARY  | Возврат из функции. Слева ничего, справа выражение
|20 | MATH_ADD         | BINARY | Сложение
|21 | MATH_SUB         | BINARY | Вычитание
|22 | MATH_MUL         | BINARY | Умножение
|23 | MATH_DIV         | BINARY | Деление
|24 | MATH_SQRT        | UNARY  | Корень
|25 | MATH_SIN         | UNARY  | Синус
|26 | MATH_COS         | UNARY  | Косинус
|27 | MATH_NEGATIVE    | UNARY  | Унарный минус
|28 | MATH_DIFF        | BINARY | Оператор дифференцирования Слева выражение, справа лист-переменная с номером переменной, по которой дифференцируем
|40 | LOGIC_GREAT      | BINARY | >
|41 | LOGIC_LOWER      | BINARY | <
|42 | LOGIC_NOT_EQUAL  | BINARY | !=
|43 | LOGIC_EQUAL      | BINARY | ==
|44 | LOGIC_GREAT_EQ   | BINARY | >=
|45 | LOGIC_LOWER_EQ   | BINARY | <=
|50 | PREFIX_ADD       | BINARY | ++x <br> 1) Слева обязательно переменная, справа, либо следующий препост-оператор, либо ничего, либо переменная (последние два варианта означают одно и то же). В таком списке операторов все переменные должны иметь один номер. Такое дублирование сделано для оптимального чтения на бекенде; <br> 2) Сначала только префиксные операторы, потом только постфиксные. То есть префиксный не может быть потомком постфиксного. <br><br> Аналогично для всех препост-операторов
|51 | PREFIX_SUB       | BINARY | --x
|52 | POSTFIX_ADD      | BINARY | x++
|53 | POSTFIX_SUB      | BINARY | x--
|60 | WHILE            | BINARY | while. Слева вычисляемое выражение, справа либо список команд, либо ELSE
|61 | DO_WHILE         | BINARY | do {} while (). Аналогично, ELSE нельзя
|63 | IF               | BINARY | Аналогично
|64 | DO_IF            | BINARY | do {} if () - условный блок с пост-условием. В случае невыполнения программа завершается с ошибкой (вероятен segmentation fault или другое неопределённое поведение)
|66 | ELSE             | BINARY | Слева список команд, если выполняется основная ветвь, справа если else ветвь
|67 | BREAK            | LEAF   | break
|68 | CONTINUE         | LEAF   | continue
|69 | NEW_SCOPE        | UNARY  | Новая область видимости переменных. Слева ничего, справа список команд
|70 | IN               | LEAF   | команда ассемблера `in`
|71 | OUT              | UNARY  | команда ассемблера `out`. Слева ничего, справа выражение
|72 | SHOW             | LEAF   | команда ассемблера `shw`
|73 | SET_FPS          | UNARY  | команда ассемблера `fps`. Слева ничего, справа выражение, которое можно вычислить во время компиляции (константное)

Узлы могут быть 3 типов:

- `1` - оператор. Значение - номер оператора из таблицы
- `2` - число. Значение - число
- `3` - переменная. Значение - номер переменной

Также для каждого узла хранится информация о том, какому символу исходного кода он соответствует. Это позволяет выводить информацию об ошибках, а также отлаживать кодогенератор.

Полное описание, формат текстового файла для передачи дерева и прочая информация в [репозитории стандарта](https://github.com/ralex2304/LangStandard/#стандарт-ast---abstract-syntax-tree).

#### Обработка синтаксических ошибок

При выявлении синтаксической ошибки выводится `gcc`-подобное сообщение.

<img rel="Синтаксическая ошибка" src="img/syntax_error.png" width="75%">

### Middleend

Данная программа использует наработки из [проекта математического дифференциатора](https://github.com/ralex2304/differentiator).

#### Возможности

- свёртка константных выражений;
- упрощение математических выражений:
    - удаление нейтральных элементов (`x + 0`, `x * 1`);
    - свёртка выражений независимым результатом (`x * 0`);
    - удаление парных постфиксных и префиксных операторов (`x++--`);
- удаление мёртвого кода;
- математическое дифференцирование по произвольной переменной.

#### Реализация оптимизаций

Для проведения оптимизаций введена дополнительная классификация типов узлов-операторов дерева:

| # | Name       | Description |
|:-:|:-----------|:------------|
| 0 | `NO_MATH`  | Не является математическим выражением
| 1 | `MATH`     | Математический оператор, оба потомка являются математическими выражениями
| 2 | `MATH_L`   | Не математический оператор, левый потомок - математическое выражение
| 3 | `MATH_R`   | Не математический оператор, правый потомок - математическое выражение
| 4 | `MATH_L_R` | Не математический оператор, оба потомка - математические выражения

#### Предупреждения

Например, выявляются константные условные выражения и выдаются предупреждения о недостижимости участка кода:

<img rel="Предупреждение о константном условии" src="img/const_clause_warning.png" width="75%">

### Backend

// TODO описание бекенда

### IR Backend

// TODO описание IR бекенда

## Заметки о разработке

### Развитие проекта

Проект создавался в конце первого семестра обучения как компилятор собственного языка для разработанного ранее [программного стекового процессора (SPU)](https://github.com/ralex2304/Processor). Компилятор генерировал только текстовый ассемблерный текст.

Во втором семестре была поставлена задача трансляции для `x86-64`. Сначала в существующий backend было добавлено создание ассемблерного текста для `nasm`. Выбор между двумя архитектурами был реализован через таблицу указателей на функции, что позволило очень легко интегрировать нововведения в проект.

Далее было принято решение о создании промежуточного представления для проведения некоторых оптимизаций для `x86-64`. Они стали возможны, так как SPU осуществляет все математические операции через стек. Соответственно некоторые действия можно свернуть или удалить.

С этого момента backend генерирует архитектурно-независимое линейное промежуточное представление программы (IR). Был создан IR backend. В нём реализованы оптимизации промежуточного представления и генерация кода для обеих архитектур. В том числе добавлено создание бинарного исполняемого файла `elf64`.

### Отладка

Для облегчения отладки были созданы несколько инструментов логирования и графические дампы некоторых структур данных:

- [Stack](https://github.com/ralex2304/Stack) - стек. Используется в backend для реализации областей видимости переменных и в IR backend для оптимизаций.
- [Tree](https://github.com/ralex2304/Tree) - бинарное дерево. Используется для работы с AST.
- [List](https://github.com/ralex2304/List) - двусвязный список. Используется для работы с IR.

#### Логи

Пример HTML лога, создаваемого при ошибке верификатора двусвязного списка, содержащего IR. В логе специально не используются сложные HTML структуры, так как при большом размере лога не всегда есть возможность открытия браузером. Поэтому нельзя было нарушить читаемость в текстовом виде. В конце каждого блока вставлена картинка с графическим представлением содержимого списка.

```
<pre>
<font color="red">!!! POISON_VAL_FOUND: There is poison value in list
</font></pre>
<pre>
<font color="red">!!! DAMAGED_PATH: List is damaged. Invalid path
</font></pre>
<pre>
    list_dump() called from ../shared/List/list.cpp:51 list_dtor
    r[0x7a29e7400020] initialized in ../shared/ir_reader/ir_reader.cpp:52 read_ir_process_
    {
    real capacity  = 33
    size           = 2
    head           = 1
    tail           = 0
    free_head      = 1
    is_linear      = true
        {
          i | prev | next | elem       | src[0]           | src[1]           | dest             | subtype
          0 |    0 |    1 | type =  -1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |
          1 |    0 |    2 | type =   1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |
          2 |    1 |    3 | type =  -1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |
          3 |   -1 |    4 | type =  -1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |
          4 |   -1 |    5 | type =  -1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |
          5 |   -1 |    6 | type =  -1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |

          ...

         32 |   -1 |    0 | type =  -1 | {NONE, -}        | {NONE, -}        | {NONE, -}        |
        }
    Ordered elements: type = 1 type = -1 type = -1
    Physical indexes: 1 2 3
    }
</pre>
<img src="../../log/08-05-2024_02-05-45/0.svg">
```

#### Графические дампы

Пример графического дампа AST. Картинка создана автоматически при помощи `graphviz`.

![Дамп AST](img/tree_dump.png)

## Зависимости

### Зависимости сборки

1. [`GNU make`](https://www.gnu.org/software/make/) - система сборки
2. [`clang`](https://clang.llvm.org/) - компилятор - можно заменить на `gcc`, изменив четыре `Makefile`
3. [`bear`](https://github.com/rizsotto/Bear) - *необязательно (`make build nobear=1`)* - утилита для создания файла `compile_commands.json`

#### Библиотеки

1. `Tree` и/или `TreeDebug` - [релизы](https://github.com/ralex2304/Tree/releases) - библиотека для работы с бинарными деревьями

##### Установка

Заменить символические ссылки в директории `./lib` на папки с файлами `.h` и `.a`. Скачать их можно в разделе `Releases` соответствующих библиотек

### Зависимости компиляции

1. [`iconv`](https://ru.wikipedia.org/wiki/Iconv) - используется скриптом `compiler.sh` для отображения русских символов в консоли
2. [`graphviz dot`](https://graphviz.org/docs/layouts/dot/) - *необязательно* - графический дамп внутренних структур программ при ошибках (только в Debug версии)

## Использование

### Сборка

```
make build <release=1> <nobear=1>
```

#### Release версия

- опция компиляции `-O2`.

```
make build release=1
```
#### Debug версия

- верификаторы структур данных;
- логирование внутренних ошибок;
- sanitizer;
- опция компиляции `-Og`;
- assert.

```
make build
```

### Компиляция программы

> [!NOTE]
> По умолчанию выбрана архитектура `x86-64`

```
./compiler.sh <file>
```

#### Опции компиляции

| Опция              | Описание |
|:-------------------|:---------|
| `--help`           | Вывести опции компиляции
| `-o <file>`        | Задать имя выходного файла
| `-m={spu\|x86_64}` | Выбрать архитектуру
| `-l=<file>`        | Задать имя объектного файла библиотеки ввода/вывода
| `-S`               | Включить генерацию текстового ассемблерного листинга

## Источники

// TODO источники

## Благодарности

- Преподаватель [Илья Дединский aka Дед](https://github.com/ded32)
- Ментор [Алексей Дурнов](https://github.com/Panterrich)

Спасибо за замечательный курс, за то, что делились опытом, и за ваше безграничное терпение! :heart:&nbsp;Meow&nbsp;:heart:
